This test checks that the varint encoding behaves the same as the Python reference implementation.

At a high level, this encodes several error-prone numbers with both Python and godobuf, base64-encodes both and ensures they are the same. We use base64 rather than plain bytes because that makes it more human readable to compare, especially when debugging the test itself.

Before you can run the tests, you need to compile the `varint.proto` with godobuf into a gdscript file named `varint.gd`.
You will also need to have Python 3.x installed and you need a way to run Jupyter notebooks (e.g. Anaconda or Visual Studio Code).
And you will need to have the protobuf compiler installed and create the Python code from `varint.proto` 

To run the tests, open `test.ipynb` in Jupyter or VS Code.
Edit the first cell to enter the path to your Godot executable.
Then run all cells with a Python 3.x kernel.

If the test succeeds, it should print several lines of `<type> <number> ok`. For example `Int64 -1 ok`.
If godobuf and Python do not match, it prints the base64 encoded bytes produced by both implementations.


# Files explained:

## proto.gd
Generated by godobuf compiler from varint.proto.

## test.ipynb
The main "test runner". This notebook ensures that dependencies are installed. Then it goes through a series of test cases and serializes the field type / number combinations in both godobuf and Python and compares the results.

## varint.proto
The protobuf definitions for the various tests (Int64, Int32, Sint64).

## varint.gd
The gdscript bindings create by compiling `varint.proto` with godobuf.

## varint_pb2.py
The Python bindings created with `protoc --python_out=. varint.proto`

## varint_test.gd
The Godot side of the test. We run this with `godot -s test.gd -- <type> <number> <outfile>`. 
For example: `godot -s test.gd -- Int64 255 out.txt`

It instantiates a protobuf message of the given type, assigns the given number into its `n` field, serializes it and saves the base64-encoded bytes into the given output file.

